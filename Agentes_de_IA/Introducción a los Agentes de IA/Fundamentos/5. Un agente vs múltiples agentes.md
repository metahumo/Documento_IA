
---

# Agente Único vs. Sistema Multi-Agente en IA

Los agentes basados en modelos de lenguaje pueden operar de dos formas principales:

1. **Agente único:** un solo LLM que intenta resolver todas las tareas.
    
2. **Sistema multi-agente:** varios agentes especializados que colaboran, cada uno con funciones y capacidades específicas.
    

Ambos enfoques tienen ventajas y limitaciones. Entender cuándo usar cada uno es clave para diseñar soluciones eficientes, escalables y económicas.

---

# 1. ¿Qué es un agente único?

Un agente único es un solo modelo de lenguaje que:

- recibe la entrada,
    
- la analiza,
    
- ejecuta herramientas (si existen),
    
- toma decisiones,
    
- y produce la salida final.
    

Es la estructura más simple.

### Ventajas

- Fácil de implementar.
    
- Menos infraestructura.
    
- Menos comunicación interna.
    
- Ideal para tareas simples o lineales.
    

### Limitaciones

- Se sobrecarga con tareas complejas.
    
- No es eficiente en dominios diversos.
    
- La calidad depende de un único modelo.
    
- El coste aumenta si se necesita un LLM muy potente para todo.
    

---

# 2. ¿Qué es un sistema multi-agente?

Un sistema multi-agente está compuesto por **varios agentes**, cada uno con:

- un propósito concreto,
    
- un estilo de razonamiento,
    
- un conjunto de herramientas,
    
- y a veces incluso **un modelo de lenguaje distinto**.
    

Estos agentes colaboran para resolver problemas más complejos que un agente único manejaría con dificultad.

### Ventajas

- **Especialización:** cada agente se diseña para una habilidad concreta.
    
- **Eficiencia:** no hace falta usar un LLM grande para todo.
    
- **Modularidad:** se pueden añadir o sustituir agentes fácilmente.
    
- **Robustez:** si uno falla, los otros pueden continuar.
    
- **Mejor razonamiento general:** diferentes modelos aportan diferentes capacidades.
    

### Desventajas

- Mayor complejidad arquitectónica.
    
- Necesidad de coordinación entre agentes.
    
- Coste adicional si la comunicación entre agentes es remota.
    

---

# 3. Ejemplo práctico (no técnico)

## Planificación de un viaje

### Agente único:

Un solo agente debe:

- buscar vuelos,
    
- comparar precios,
    
- leer reseñas de hoteles,
    
- diseñar un itinerario,
    
- organizar actividades diarias,
    
- calcular presupuesto,
    
- recomendar restaurantes.
    

Esto crea prompts gigantes, más consumo de tokens y un LLM que debe saber de todo.

---

### Sistema multi-agente:

- **Agente Vuelos:** busca rutas y precios.
    
- **Agente Hoteles:** filtra alojamiento por preferencias.
    
- **Agente Itinerarios:** crea actividades por día.
    
- **Agente Presupuesto:** calcula costes.
    
- **Agente Resumen:** consolida toda la información en un plan optimizado.
    

Aquí podemos usar modelos distintos:

- Agentes simples → modelos ligeros (baratos).
    
- Agentes creativos → modelos más grandes.
    
- Agentes de síntesis → modelos razonadores.
    

Esto reduce coste y mejora calidad.

---

# 4. Ejemplo aplicado a ciberseguridad

Supongamos un laboratorio de enumeración y análisis de vulnerabilidades.

## Agente único (problemas):

Un solo modelo debe realizar:

- escaneo de red,
    
- análisis de servicios,
    
- análisis de CVEs,
    
- correlación con exploit-db,
    
- generación de PoCs,
    
- redacción de informes técnicos,
    
- priorización de riesgos.
    

Esto genera:

- prompts muy largos,
    
- riesgo de errores,
    
- coste elevado si necesitamos modelos grandes,
    
- razonamiento inconsistente.
    

---

# Sistema multi-agente especializado (ciberseguridad)

### Agente 1 → Enumerador

- Usa herramientas: nmap, whois, nslookup
    
- Analiza puertos y servicios
    

### Agente 2 → Analista de vulnerabilidades

- Interpreta banners, versiones
    
- Busca CVEs asociados
    
- Sugiere vectores de ataque
    

### Agente 3 → Investigador técnico

- Lee exploits
    
- Genera PoCs controladas
    
- Simula escenarios
    

### Agente 4 → Redactor de informes

- Resume hallazgos
    
- Estructura documentos
    
- Crea conclusiones y mitigaciones
    

### Agente 5 → Coordinador

- Lee la petición del usuario
    
- Decide qué agente activar
    
- Coordina el flujo de trabajo
    

Esto es más eficiente porque:

- Los agentes de enumeración pueden usar **modelos pequeños o reglas sin LLM**.
    
- Los agentes de análisis profundo pueden usar **modelos grandes**, pero solo cuando es necesario.
    
- El redactor puede ser un modelo intermedio.
    
- El coordinador puede ser un LLM razonador con función de direccionamiento.
    

---

# 5. ¿Por qué usar varios LLM es más eficiente y menos costoso?

|Tarea|LLM recomendado|Motivo|
|---|---|---|
|Parsing de logs|Modelo pequeño|Son tareas mecánicas|
|Análisis de vulnerabilidades|Modelo mediano|Requiere contexto pero no creatividad|
|Generación de PoC|Modelo grande|Requiere razonamiento y precisión técnica|
|Redacción de informe|Modelo mediano|Lenguaje + estructuras|
|Coordinación|Modelo fuerte en razonamiento|Orquesta a los demás|

Al separar tareas:

- Reducimos el número de tokens enviados a modelos grandes.
    
- Aprovechamos modelos locales o ligeros cuando es posible.
    
- Aumentamos la fiabilidad y la mantenibilidad del sistema.
    
- Disminuimos el coste global.
    

---

# 6. Ejemplo de arquitectura multi-agente (código simplificado)

```python
class Coordinador:
    def __init__(self, agente_enum, agente_vuln, agente_informe):
        self.agente_enum = agente_enum
        self.agente_vuln = agente_vuln
        self.agente_informe = agente_informe

    def ejecutar(self, objetivo):
        print("==> Coordinando flujo")

        puertos = self.agente_enum.enumerar(objetivo)
        vulns = self.agente_vuln.analizar(puertos)
        informe = self.agente_informe.redactar(vulns)

        return informe


class AgenteEnumeracion:
    def enumerar(self, objetivo):
        return ["22/ssh", "80/http"]


class AgenteVulnerabilidades:
    def analizar(self, servicios):
        return {"80/http": "Posible XSS", "22/ssh": "Versión antigua"}


class AgenteInforme:
    def redactar(self, vulns):
        return f"Informe generado: {vulns}"


coord = Coordinador(
    AgenteEnumeracion(),
    AgenteVulnerabilidades(),
    AgenteInforme()
)

print(coord.ejecutar("10.10.10.5"))
```

---

# 7. Resumen final

Los sistemas multi-agente representan una evolución natural en el diseño de agentes complejos:

### Agente único

- Simple
    
- Útil para tareas pequeñas
    
- Se vuelve costoso e inestable en proyectos grandes
    

### Sistema multi-agente

- Modular
    
- Escalable
    
- Barato
    
- Preciso
    
- Capaz de combinar varios modelos de lenguaje
    
- Ideal para ciberseguridad, automatizaciones y análisis continuado
    

La especialización por agente refleja cómo funcionan los verdaderos equipos humanos:  
**cada uno con su papel, su contexto y sus herramientas → coordinados hacia un único objetivo.**

---
